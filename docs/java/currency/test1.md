# Table of Contents

  * [简介](#简介)
    * [一、Java内存区域（JVM内存区域）](#一、java内存区域（jvm内存区域）)
    * [二、Java内存模型](#二、java内存模型)
  * [三、as-if-serial语义、happens-before原则](#三、as-if-serial语义、happens-before原则)
    * [3.1 as-if-serial语义](#31-as-if-serial语义)
    * [3.2 happens-before原则](#32-happens-before原则)
    * [3.3 happens-before定义](#33-happens-before定义)
    * [3.3 happens-before对比as-if-serial](#33-happens-before对比as-if-serial)
    * [3.4 happens-before具体规则](#34-happens-before具体规则)
    * [3.5 happens-before与JMM的关系图](#35-happens-before与jmm的关系图)
  * [四、volatile、锁的内存语义](#四、volatile、锁的内存语义)
    * [4.1 volatile的内存语义](#41-volatile的内存语义)
    * [4.2 volatile内存语义的实现](#42-volatile内存语义的实现)
    * [4.3 锁的内存语义](#43-锁的内存语义)
    * [4.4 final域的内存语义](#44-final域的内存语义)
  * [五、JMM是如何处理并发过程中的三大特性](#五、jmm是如何处理并发过程中的三大特性)
  * [参考链接：](#参考链接：)


本文转自 https://www.cnblogs.com/kukri/p/9109639.html

## 简介

首先介绍两个名词：

- 可见性:一个线程对共享变量值的修改,能够及时地被其他线程看到。
- 共享变量:如果一个变量在多个线程的工作内存中都存在副本,那么这个变量就是这几个线程的共享变量　　

Java线程之间的通信对程序员完全透明，在并发编程中，需要处理两个关键问题：**线程之间如何通信及线程之间如何同步**。

- 通信：通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态来进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来进行显示通信。
- 同步：同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显示进行的，程序员必须显示指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

Java并发采用的是共享内存模型。

## 一、Java内存区域（JVM内存区域）

![](https://images2018.cnblogs.com/blog/1332556/201805/1332556-20180530105521301-2013126296.png)

Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。

*   方法区（Method Area）：

    方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。

*   JVM堆（Java Heap）：

    Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。

*   程序计数器(Program Counter Register)：

    属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

*   虚拟机栈(Java Virtual Machine Stacks)：

    属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。栈中只保存基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）：

    ![](https://img-blog.csdn.net/20170608151435751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

*   本地方法栈(Native Method Stacks)：

    本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。

## 二、Java内存模型

Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在。Java线程之间的通信由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系。

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行。


首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图

![](https://images2018.cnblogs.com/blog/1332556/201805/1332556-20180530110846270-1135031810.png)

图3

需要注意的是，JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开的(稍后会分析)。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下

> *   主内存
>
>     主要存储的是Java实例对象以及线程之间的共享变量，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。
>
> *   工作内存
>
>     有的书籍中也称为本地内存，主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。
>     
>     注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。注意，**工作内存是JMM的一个抽象概念，并不真实存在。**
>

弄清楚主内存和工作内存后，接了解一下主内存与工作内存的数据存储类型以及操作方式，根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。

**但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中**。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，简单示意图如下所示：

![](https://images2018.cnblogs.com/blog/1332556/201805/1332556-20180530111627434-363867932.png)

图4

从图3来看，如果线程A与线程B之间要通信的话，必须经历下面两个步骤：

1）线程A把本地内存A中更新过的共享变量刷新到主内存中去

2）线程B到主内存中去读取线程A之前已更新过的共享变量

从以上两个步骤来看，共享内存模型完成了“隐式通信”的过程。

JMM也主要是通过控制主内存与每个线程的工作内存之间的交互，来为Java程序员提供内存可见性的保证。

## 三、as-if-serial语义、happens-before原则

### 3.1 as-if-serial语义

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。

但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

### 3.2 happens-before原则

happens-before是JMM最核心的概念。对应Java程序来说，理解happens-before是理解JMM的关键。

> 设计JMM时，需要考虑两个关键因素：
>
> *   程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。
> *   编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现弱内存模型。
>

但以上两点相互矛盾，所以JSR-133专家组在设计JMM时的核心膜表就是找到一个好的平衡点：

- 为程序员提高足够强的内存可见性保证；

- 对编译器和处理器的限制尽可能地放松。

另外还要一个特别有意思的事情就是关于重排序问题，更简单的说，重排序可以分为两类：

- 会改变程序执行结果的重排序。

- 不会改变程序执行结果的重排序。 

JMM对这两种不同性质的重排序，采取了不同的策略，如下：

*   对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。 
*   对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种 重排序） 

JMM的设计图为： 

![](https://images2018.cnblogs.com/blog/1332556/201806/1332556-20180611104204152-1569228705.png)

JMM设计示意图 从图可以看出：

*   JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens-before B）。 
*   JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。

### 3.3 happens-before定义

happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：

> 1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
>
> 2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。
>
> 上面的1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！
>
> 上面的2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。
>

### 3.3 happens-before对比as-if-serial

*   as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
*   as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。
*   as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。

### 3.4 happens-before具体规则

*   程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
*   监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
*   volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 
*   传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
*   start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
*   join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

### 3.5 happens-before与JMM的关系图

![](https://images2018.cnblogs.com/blog/1332556/201806/1332556-20180611201524034-1587404964.png)

一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法

复用类的两种方式 

- 第一种方法非常直接：只需要在新的类中产生现有类的对象。由于新的类是由现有类的对象所组成，所以这种方法称为组合。
- 第二种方法更加细致一些，它按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种神奇的方式称为继承。

## 1 组合语法

初始化引用的四种方式：

- 在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。
- 在类的构造器之中。
- 正要使用这些对象之前，这被称为惰性初始化。在生成对象不值得及不必要每次都生成对象的情况下，这种方式可以减少额外的负担。
- 使用实例（块代码）初始化。

## 2 继承语法

继承会自动得到基类所有的域和方法。

super.xxx：调用父类的域或方法。

super(args)：根据参数列表调用父类相应的构造器

为了继承，一般的规则是将所有的数据成员指定为private，将所有的方法指定为public。

### 2.1 初始化基类

Java会自动在导出类的构造器之中插入对基类构造器的调用。调用基类构造器是在导出类构造器之中要做的第一件事。

构建过程是从基类向外扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。即使你不为Cartoon()创建构造器，编译器也会为你合成一个默认的构造器，该构造器将调用基类的构造器。

## 3 代理

代理可以拥有更多的控制力，因为我们可以选择只提供在成员对象中的方法的某个子集。

## 4 结合使用组合和继承

### 4.1 确保正确清理

析构函数是一种在对象被销毁时自动调用的函数。

清理的形式与析构函数相同：首先，执行类的所有特定的清理动作，其顺序同生成顺序相反（通常这就要求基类元素仍旧存活）；然后，就如我们所示范的那样，调用基类的清理方法。

垃圾回收器可能永远也无法被调用，即使被调用，他也可能以任何它想要的顺序来回收对象。最好的办法是除了内存以外，不能依赖垃圾回收器去做任何事。如果需要进行清理，组好是编写子集的清理方法，但不要使用finalize()。

### 4.2 名称屏蔽

可以添加和基类方法重载的新方法。

复写开发工具会提示@override，注意必要混淆重载和复写。

## 5 在组合和继承之间的选择

组合和继承都允许在新的类之中放置子对象。组合是显式地这么做，而继承是隐式地做。

组合技术通常用于想在新类中使用现有类的功能，而非他的接口的这种形式。即:在新类中嵌入某个对象，让其实现所需求的功能，但新类的用户看到的只是为新类定义的接口，而非所有嵌入对象的接口。为取得此效果，需要在新类中嵌入一个现有类的private对象。

有时，允许类的用户直接访问新类中的组合成分是极具意义的。也就是说，将成员对象声明为public。如果成员自身都隐藏了具体实现，那么这种做法是安全的。当用户能够了解到你正在组装一组部件时，会使得端口更加易于理解。但是一般情况下应该使域成为private。

is_a:是一个，这种关系用继承来表达。

has_a:有一个，组合。

## 6 protected关键字

就一般类用户来说他是private的，但是对于任何继承于此类的导出类或其他任何位于同一包内的类来说，他却是可以访问的。protected提供了包访问权限。

尽管可以创建protected域，但是最好的方式还是将域保持为private，你应当一直保留更改底层实现的权利。

## 7 向上转型

### 7.1 为什么称为向上转型

由导出类转型为基类，在继承图上是向上移动的，因此一般称为向上转型。由于向上转型是从一个较专用类型转为较为通用类型的转换，所以总是安全的。向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。

### 7.2 再论组合和继承

到底是该使用组合还是继承，一个最清晰的判断方法是问一问自己是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。

## 8 final关键字

### 8.1 final数据

- 一个永不改变的编译时常量
- 一个在运行时被初始化的值，而你不希望他被改变

对于编译时常量这种情况，编译器可以将该常量值代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算，这减轻了一些运行时的负担。在Java中，这类常量必须是基本数据类型，并且以关键字final表示。在对这个常量进行定义的时候，必须对其进行赋值。

一个即使static又是final的域只占据一段不能改变的存储空间。

对于基本类型，final使数值恒定不变，而用于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把他指向另一个对象。然而，对象自身确实可以修改的，Java并未提供使任何对象恒定不变的途径。这一限制同样使用数组，它也是对象。使引用成为final没有使基本类型成为final用处大。

定义为public，可以被用于包外。

定义为static，则强调只有一份。

定义为final，则说明他是一个常量。

**空白final：**所谓空白final是指被声明为final，又未给定初始值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。但是空白final在使用上提供了更大的灵活性，为此，一个类中的final域就可以做到根据对象而有所不同。

必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。

**final参数：**你可以读参数，却无法修改参数。这一特性主要用来向匿名内部类传递参数。

### 8.2 final方法

使用final方法的原因：

- 把方法锁定，以防任何继承类修改它的含义。这是处于涉及的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。
- 效率。

类中所有的private方法都隐式指定为final的。由于无法取得private方法，所以也就无法覆盖他。可以对private方法添加final修饰符，但是不能给该方法增加任何额外的意义。

### 8.3 final类

当将某个类的整体定义为final时，就表明你不打算继承该类，而且也不允许别人这样做。final类的域可以根据 个人意愿选择式或不是final。final类禁止继承，所final类中所有的方法都隐式指定为final的，因为无法覆盖它们。

### 8.4 有关final的忠告

vector--->ArrayList

HashTable--->HashMap

## 9 初始化及类的加载

初次使用之处也是static初始化发生之处。所有的static对象和static代码段都会在加载时依程序中的顺序而依次初始化。

### 9.1 继承和初始化

参考代码

1. 走main方法，暂时不执行。
2. 找基类。
3. 走static方法（由基类到拓展类）
4. 执行main方法
5. 基类变量初始化->基类构造器
6. 拓展类变量初始化->扩展类构造器

## 10 总结

组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口。

优先选择使用组合（或者代理），只在确实必要时才使用继承。因为组合更具有灵活性。        
# 接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。 

抽象类是普通类与接口之间的一种中庸之道。

## 1 抽象类和抽象方法

创建抽象类是希望通过这个通用接口操纵一系列类。

抽象方法不完整，只有声明没有方法体。

包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。（否则，编译器就会报错）。

如果从一个抽象类继承，并想创建该类的对象，那么就**必须为基类中的所有抽象方法提供方法定义。**如果不这样做（可以选择不这样做），那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。

创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动。

## 2 接口

abstract关键字允许人们在类中创建一个或多个没有任何定义地方法---提供了接口部分，但是没有提供任何相应地具体实现，这些实现是由此类的继承者创建的。interface这个关键字产生一个完全抽象的类，它根本就没有提供任何具体的实现。它允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体。

一个接口表示：所有实现了该特定接口的类看起来都像这样。

interface不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承变种的特性。

**接口也可以包含域，但是这些隐式地使static和final的。**

可以选择在接口中显式地将方法声明为public地，但即使你不这样做，它们也是public的。

因此，当要实现一个接口时，在接口中被定义的方法必须被定义为public的，否则，她们将只能得到默认的包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是java编译器所不允许的。

## 3 完全解耦

使用接口可以编写可复用性很好的代码。

创建一个可以根据所传递的参数对象的不同而具有不同行为的方法，被称为**策略设计模式**。这类方法包含所要执行的算法中固定不变的部分，而策略包含变化的部分。策略就是传递进去的参数对象，它包含要执行的代码。

适配器模式。

将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码也就更具可复用性。

## 4 Java中的多重继承

多重继承时，继承必须放在实现之前。

具体类向上转型为接口。

使用接口的核心原因：为了能够向上转型为多个基类型（以及由此而带来的灵活性）。然而，使用接口的第二个原因却是与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。

如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。事实上，如果知道某事物应该成为一个基类，那么第一选择应该是使它成为一个接口。

## 5 通过继承来扩展接口

extends一般只能用于单一类，但是可以引用多个基类接口。

### 5.1 组合接口时的名字冲突

在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱，请尽量避免这种情况。

## 6 适配接口

接口最吸引人的原因之一就是允许同一个接口有多个不同的具体实现。在简单的情况中，它的体现形式通常是一个接受接口类型的方法，而该接口的实现和向该方法传递的对象则取决于方法的使用者。因此接口的一种常见用法就是前面提到的策略设计模式。

让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。这就是使用接口而不是类的强大之处。

## 7 接口中的域

### 7.1 初始化接口中的域

在接口中定义的域不能是空final，但是可以被非常量表达式初始化。Random（）

既然域是static的，它们就可以在类第一次被加载时初始化，这发生在任何域首次被访问时。

当然，这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。

## 8 嵌套接口

## 9 接口和工厂方法

接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式。

更加优雅的工厂实现方式---使用匿名内部类。

## 10 总结

恰当的原则应该是优先选择类而不是接口。从类开始，如果接口的必需性变得非常明确，那么就进行重构。
## 1 用构造器确保初始化 

- 在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。
- 构造器的名称必须与类名完全相同，因此每个方法首字母小写的编码风格并不适用于构造器。
- 从概念上来讲，初始化和创建是彼此独立的，在Java中，初始化和创建是捆绑在一起的，彼此不能分离。
- 构造器是一种特殊的方法，因为它没有返回值。这与返回值为空（void）有明显不同。

## 2 方法重载

为了让方法名相同而形参不同的构造器同时存在，必须用到方法重载。

### 2.1 区分重载方法

每个重载的方法必须有一个独一无二的参数列表，甚至连参数顺序的不同也可以区分两个方法。

### 2.2 涉及基本类型的重载

如果传入的数据类型小于方法中声明的形参类型，实际数据类型就会提升。

如果传入的实际参数较大，就会通过类型转换了来执行窄化转换。

### 2.3 以返回值区分重载方法

行不通

## 3 默认构造器

如果已经定义了一个构造器（无论是否），编译器就不会帮你自动创建默认的构造器。

## 4 this关键字

- this关键字只有在方法内部使用，表示对"调用方法的那个对象"的引用。如果在方法内部调用同一个类中的另一个方法，就不必使用this，直接调用即可（编译器能帮你自动添加，只有当需要明确指出对当前对象的引用时，才需要this关键字）。

### 4.1 在构造器中调用构造器

- this调用构造器，只能调用一个，必须将构造器置于最起始处，否则编译器会报错。
- 由于参数s的名称和数据成员s的名字相同，所以会产生歧义。使用this.s来代表数据成员就能解决这个问题。
- 除了构造器之外，编译器禁止在其他任何地方调用构造器。

### 4.2 static的含义

- static方法就是没有this的方法。
- 在静态方法内部不能调用非静态方法，反过来可以。

## 5 清理：终结处理和垃圾回收

由于垃圾回收器只知道释放那些经由new分配的内存，所以他不知道该如何释放该对象的这块特殊内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。他的工作方法假定是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做些重要的清理工作。

只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是正确的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销。

### 5.1 finalize()的用途何在

todo

### 5.2 你必须实施清理

todo

### 5.3 终结条件

todo

### 5.4 垃圾回收器如何工作

todo

## 6 成员初始化

编译器默认会为方法的局部变量赋一个默认值，但是未被初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。因此强制程序员提供一个初始值，往往能帮我梦找到程序里的缺陷。

类里定义一个对象引用，如果不将其初始化，此引用就会获得一个特殊值null。

## 7 构造器初始化

### 7.1 初始化顺序

在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散落在方法定义之间，他们仍然会在任何方法（包括构造器）被调用之前得到初始化。

### 7.2 静态数据的初始化

无论创建多少对象，静态数据都只占一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个静态的基本数据类型域内有进行初始化，那么他就会获得基本类型的标准初值，如果他是一个对象引用，那么它的默认初始化值就是null。

静态初始化只有在必要时刻才会进行。只有在第一个Table对象被创建时候，他们才会被初始化。此后，静态对象不会再被初始化。

初始化的顺序是先静态对象（如果他们尚未因为前面对象的创建而被初始化），而后是非静态对象。

构造器实际上也是静态方法。

### 7.3 显式的静态初始化

Java允许将多个静态初始化动作组织成一个特殊的"静态子句"，也叫静态块。与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）。

### 7.4 非静态实例的初始化

不加static的块，这种语法对于支持匿名内部类的初始化是必须的，但是它也使得你可以保证无论调用了哪个显式构造器，某些操作都会发生。

## 8 数组的初始化

- int[] a1;
- int a1[];

上述两种方式是一样的，后一种更符合C和C++程序员的习惯。

编译器不允许指定数组的大小。

为了给数组创建相应的存储空间，必须写初始化表达式。

数组的创建是在运行时刻进行的。它初始化是在运行的过程中实现的。

### 8.1 可变参数列表

有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你去填充数组。

0个参数传递给可变参数列表也是可行的，具有可选的尾随参数时，这一特性就会很有用。

可变参数列表可以和自动包装机制和谐共处。

## 9 枚举类型

枚举实例按照命名惯例必须大写字母表示，如果一个名字中有多个单词，用下划线将他们隔开。

编译器会为enum自动添加一些有用的特性。例如：

- toString() 方便显示某个enum实例的名字
- ordinal() 某个特定enum常量的声明顺序
- static values() 按照enum常量的声明顺序，产生由这些常量构成的数组

enum特别实用的特性，在switch语句中内使用。由于switch是要在有限的集合中进行选择，因此它与enum正是绝佳的组合。
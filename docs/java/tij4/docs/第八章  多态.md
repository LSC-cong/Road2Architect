在面向对象编程语言中，多态是继数据抽象和继承之后的第三种基本特征。

多态通过分离做什么和怎么做，将接口和实现分离开来。

封装通过合并特征和行为来创建新的数据类型。多态的作用是消除类型之间的耦合关系。

多态，也称作动态绑定，后期绑定或运行时绑定。

## 1 再论向上转型

把对某个对象的引用视为对其基类型的引用的做法被称作向上转型。

## 2 转机

### 2.1 方法调用绑定

将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。面向过程的 语言中不需要选择就默认的绑定方式。

后期绑定的含义就是在运行时根据对象的类型进行绑定。后期绑定也叫做动态绑定或运行时绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时就能判定对象的类型，从而调用恰当的方法。也就是说，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。

**Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。**这意味着通常情况下，我们不必判定是否进行后期绑定->它会自动发生。

final声明方法的最重要一点：关闭动态绑定，告诉编译器不需要对其进行动态绑定。

### 2.2 产生正确的行为

一旦知道Java中所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有的导出类都可以正确运行。



### 2.3 可扩展性

一个设计良好的OOP程序中，大多数或者所有的方法都只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添加一些功能。那些操纵基类接口的方法不需要任何改动就可以引用于新类。我么所做的修改不会对程序中其他不应受到影响的部分产生破坏。换句话说，多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。



### 2.4 缺陷：“覆盖”私有方法

只有非private方法才可以被覆盖；但是还是要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切的说，在导出类中，对于基类的private方法，最好采用不同的名字。

### 2.5 缺陷：域与静态方法

只有普通的方法调用可以是多态的。如果你直接访问某个域，这个访问就将在编译器进行解析。

如果某个方法是静态的，他的行为就不具有多态性。因为静态方法与类，而并非与单个对象相关联。

## 3 构造器和多态

构造器不具有多态性。（静态方法）

### 3.1 构造器的调用顺序

只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化。因此，必须令所有的构造器得到调用，否则就不可能正确构造完整对象。这正是编译器为什么要强制每个导出类部分都必须调用构造器的原因。

1. 调用基类构造器。递归调用。
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

### 3.2 继承和清理

对于基类，应该首先对其导出类进行清理，然后才是基类。这是因为导出类的清理可能会调用基类中的某些方法，所以需要使基类中的构件起作用而不应过早地销毁它们。按创建地逆序进行销毁。

### 3.3 构造器内部地多态方法的行为

编写构造器的一条有效的准则：用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法。构造器内唯一能够安全调用的那些方法是基类中的final方法（也适用于private）。

## 4 协变返回类型

协变返回类型允许返回更具体的类型。

## 5 用继承进行设计

状态模式

通用准则：用继承表达行为间的差异，并用字段表达状态上的变化。

### 5.1 纯继承与扩展

纯替代（导出类可以完全代替基类）。

### 5.2 向下转型与运行时类型识别

Java语言中，所有的转型都会得到检查。

类型转换异常ClassCastException。

运行时类型识别RTTI。
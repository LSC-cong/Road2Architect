Java的基本理念是结构不佳的代码不能运行。 

发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。

改进的错误恢复机制是提供代码健壮性的强有力的方式。错误恢复在我们编写的每一个程序中都是基本的要素，但是在Java中它显得格外重要，因为Java的主要目标之一就是创建供他人使用的程序构件。

## 1 概念

C以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而并不属于语言的一部分。通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或标志进行检查。

异常处理机制不仅节省代码，而且把描述在正常执行过程中做什么事的代码和出了问题怎么办的代码相分离。总之，与之前的错误处理方法相比，异常机制使代码的阅读编写和调试工作更加井井有条。

## 2 基本异常

- 普通问题：在当前环境下能得到足够的信息，总能处理这个错误。
- 异常情形：阻止当前方法或作用域继续执行的问题，不能继续下去，所能做的就是从当前环境跳出，并且把问题提交给上一级环境。

抛出异常：首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象。然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。

异常使得我们可以将每件事当作一个事物来考虑，而异常可以看护着这些事物的底线。

    “······事物的基本保障是我们所需的在分布式计算中的异常处理。事物是计算机中的合同法，如果出了什么问题，我们只需要放弃整个计算。”
                                                                                                                  ------Jim Gray

### 2.1 异常参数

所有的标准异常都有两个构造器：

一个是默认构造器，

另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器。

异常类型的根类，Throwable对象。

## 3 捕获异常

监控区域，是一段可能产生异常的代码，并且跟着处理这些异常的代码。

有了异常处理机制，可以把所有的动作都放在try块里，然后只需在一个地方就可以捕获所有的异常。这意味着代码将更容易编写和阅读，因为完成任务的代码没有和错误检查的代码混在一起。

**终止模型：**在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。
**恢复模型：**异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。如果想要用Java实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。

虽然恢复模型开始显得很吸引人，但不是很实用。其中主要原因可能是它导致的耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包括依赖于抛出位置的非通用性代码。这增加了diamagnetic编写和维护的困难，对于异常可能会从许多地方抛出的大型程序来说，更是如此。

## 4 创建自定义异常

**要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。**

建立新的异常类型最简单的方法就是让编译器为你产生默认的构造器，所以这几乎不用写多少代码。

通过写入System.err而将错误发送给标准错误流。通常这比把错误信息输出到System.out要好，因为System.out也许会被重定向。如果把结果送到System.err，它就不会随System.out一起被重定向，这样更容易被用户注意到。

使用super关键字明确调用了其基类的构造器，它接受一个字符串作为参数。

**在异常处理程序中，调用了Throwable类声明的printStackTrace()方法。它将打印从方法调用处到异常抛出处的方法调用序列。**

## 5 异常说明

Java鼓励人们把方法可能会抛出的异常告诉使用此方法的客户端程序员。这是种优雅的做法，它使得调用者能确切知道写什么样的代码可以捕获所有潜在的异常。

异常说明的关键字throws，后面接一个所有潜在异常类型的列表。要么处理这个异常，要么就在异常说明中表明此方法将产生异常，通过这种自顶向下强制执行的异常说明机制，Java在编译时就可以保证一定水平的异常正确性。

作弊地方：声明方法将抛出异常，实际上却不抛出。编译器相信了这个声明，并强制此方法的用户像真的抛出这种异常那样使用这个方法。这样做的好处是，为异常先占个位置，以后就可以抛出这种异常而不用修改已有的代码。在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。

这种在编译时强制检查的异常被称为被检查的异常。

## 6 捕获所有的异常

getName()：全限定名。

getSimpleName()：类名。

### 6.1 栈轨迹

//todo



### 6.2 重新抛出异常

//todo



### 6.3 异常链

//todo

## 7 Java标准异常

//todo
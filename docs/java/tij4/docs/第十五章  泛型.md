泛型是Java SE5的重大变化之一，泛型实现了参数化类型的概念。

泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备最广泛的表达能力。如何做到这一点呢，正是通过解耦类或方法与所使用的类型之间的约束。

## 1. 与C++的比较

了解C++模板的某些方面，有助于你理解泛型的基础。同时非常重要的一点是，你可以了解Java泛型的局限是什么，以及为什么会有这些限制。最终的目的是帮助你理解，Java泛型的边界在哪里。根据我的禁言，理解了边界所在，你才能成为程序高手。因为只有知道了某个技术不能做到什么，你才能更好的做到能做的（部分原因是不必浪费时间在死胡同里面乱转）。

在Java社区中，人们普遍对C++模板有一种误解，而这种误解可能会误导你，令你在理解泛型的意图时产生偏差。

## 2. 简单泛型

泛型的主要目的之一是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。

当你创建Holder3对象时，必须指明想持有什么类型的对象，将其置于尖括号内。

告诉编译器想使用什么类型，然后编译期帮你处理一切细节。

### 2.1 一个元组类库

元组：将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许都取其中元素，但是不允许向其中存放新的对象。

## 3. 泛型接口

泛型也可以应用于接口。例如生成器（generator），这是一种专门的负责创建对象的类。实际上，这是工厂方法设计模式的一种应用。不过，当使用生成器创建新的对象的时候，他不需要任何参数，而工厂方法一般需要参数。也就是说生成器无需额外的信息就知道如何创建新对象。

一般而言，一个生成器只定义一个方法。

实现了Iterable接口，所以可以在循环语句中使用。

基本类型无法作为类型参数。不过，Java SE5具备了自动打包和自动拆包的功能，可以很方便地在基本类型和其相应的包装器类型之间进行转换。

## 4. 泛型方法

泛型方法所在的类可以是泛型类也可以不是。泛型方法能使得该方法独立于类而产生变化。

无论何时，只要你能做到，应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为他能使事情更清除明白。另外，对于一个static的方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。

要定义泛型方法，只需将泛型参数列表置于返回值之前。

当使用泛型类时，必须创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。这称为类型参数推断。因此，我们可以像调用普通方法一样调用泛型方法，而且就好像是被无限次重载过一样。

### 4.1 杆杠利用类型参数推断

类型推断只对负值操作有效，其他时候并不起作用。如果你将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断。在这种情况下，编译器认为：调用泛型方法后，其返回值被赋给一个Object类型的变量。**需要进行显式的类型说明。**

### 4.2 可变参数与泛型方法

泛型方法与可变参数列表能够很好地共存。

## 6. 构建复杂模型
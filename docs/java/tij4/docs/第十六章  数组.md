## 1. 数组为什么特殊

数组与其他种类的容器之间的区别由三方面：效率、类型和保存基本类型的能力。

在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组是一个简单的线性序列，这使得元素访问非常快。

数组对象的大小被固定。

在泛型之前，其他的容器类在处理对象时，都将他们视作没有任何具体类型。也就是说，他们将这些对象都当作Java中所有类的根类Object处理。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译期检查，来防止插入错误类型和抽取不当类型。

数组可以持有基本类型，而泛型之前的容器则不能。

随着自动包装机制的出现，容器已经可以和数组几乎一样方便地用于基本类型中了。数组硕果仅存的优点是效率。然而，如果要解决一般化的问题，那数组可能会受到过多的限制，因此在这些情形下，你还是会使用容器。

## 2. 数组是第一级对象

数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个数组对象用以保存指向其他对象的引用。对象数组和基本类型数组在使用上几乎是相同的，唯一的区别是对象数组保存的是引用，基本类型数组保存的是 基本类型的值。

声明了大小的空数组也是一个合法的对象。但是没有初始化的数组，编译器不允许用此引用做任何事情。

length是数组的大小，而不是实际保存的元素个数。

## 3. 返回一个数组

java中直接返回

## 4. 多维数组

Java SE5中的Arrays.deepToString()，可以将多维数组转换为多个String。该方法对基本类型数组和对象数组都起作用。

## 5. 数组与泛型

不能实例化具有参数化类型的数组:

Peel<Banana>[] peels = new Peel<Banana>[10]； //illegal

擦除会移除参数类型信息，而数组必须知道他们所持有的确切类型，以强制保证类型安全。

使用参数化方法而不使用参数化类的方便之处在于：你不必需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态的。当然，你不能总是选择使用参数化方法而不是参数化类，但是它应该成为首选。

## 6. 创建测试数据

反射方法getClasses()可以生成所有的嵌套类。

## 7. Arrays实用功能

equals()比较两个数组是否相等

deepEquals()用于多维数组

sort()排序

binarySearch()在已经排序的数组中查找元素

hashCode()产生数组的散列码

### 7.1 复制数组

System.arraycopy()，用它复制数组比for循环快很多，且针对所有类型进行了重载。

参数依次为：源数组，源数组的开始位置，目标数组的开始位置，需要复制的元素个数。

如果复制对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝。这被称为浅拷贝。

System.arraycopy()不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。

数组相等的条件式元素个数必须相等，并且对应位置的元素个数也相等。这可以通过对每一个元素使用equals()作比较来判断。

### 7.2 数组元素的比较

策略设计模式

实现java.lang.Comparable接口，使得你的类具有天生的比较能力。此接口很简单，只有conpareTo()一个方法。此方法接受另一个对象为参数，如果当前对象小于参数则返回负值，如果相等，则返回零，如果当前对象大于参数则返回正值。

实现Comparator接口。

### 7.4 数组排序

使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组进行排序，只要该对象实现了Comparable接口或Comparator接口。

### 7.5 在已排序的数组中查找

如果数组已经排好序，就可以使用Arrays.binarySearch()执行快速查找。如果要对未排序的数组使用binarySearch()，那么将产生不可预料的结果。

## 8. 总结

有了额外的自动包装机制和泛型，在容器中持有基本类型就变得易如反掌，而这也进一步促使你使用容器来替换数组。因为泛型可以产生类型安全的容器，因此数组面对这一变化，已经变得毫无优势。